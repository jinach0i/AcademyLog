<!DOCTYPE html>
<html>
<head>
<title>Chapter 06 클래스와 모듈</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
body { margin: 0; color: #000000; font: 14px/1.6  'Courier New', "Malgun Gothic", "맑은 고딕", DotumChe, Verdana, Arial, "Trebuchet MS"; margin: 0px; text-align: justify;}
table th, table td{font: 14px/1.6  'Courier New', "Malgun Gothic", "맑은 고딕", DotumChe, Verdana, Arial, "Trebuchet MS"; color: #333333; text-align: justify;}
table th{text-align: center;}
a:link { color: rgb(0,125,255); text-decoration: none; font-weight: bold;}
a:hover { color: rgb(255,0,0); text-decoration: none; font-weight: bold;}
a:visited { color: rgb(0,190,190); text-decoration: none; font-weight: bold;}
a:active { color: rgb(255,125,0); text-decoration: none; font-weight: bold;}
.mp{margin: 0; padding: 0; text-align: center;}
.center{text-align: center;}
#wrap {	width: 900px; margin: auto;}
#float{position: fixed; float: left; top: 5px; right: 100px; z-index: 100; border: 1px inset #efefef; font-size: 12px; color: #999999; padding: 5px;}
#float > ul{margin: 0; padding: 0;}
#float li{margin: 0; padding: 0; list-style:none; }
.article {width: 900px; color: #333333;	line-height: 180%;	text-align: left;}
.article h2 {background: #D0D7DF; border-bottom: 1px solid #C8CACE; border-top: 1px solid #C8CACE; font: 18px/1.6; font-weight: bold; margin: 25px 0px 25px 0px; padding: 10px 49px 10px 50px;}
h3 {color: #009;}
h4{font-size: 1.05em;}
h1, h2, h3, h4{margin-top: 50px;}
pre {margin: 10px 0px; padding: 0px 5px; border: 1px solid rgb(200, 202, 206);  width: 888px; overflow-x: auto; overflow-y: hidden; font: 16px/1.6  'Courier New', "Malgun Gothic", "맑은 고딕", DotumChe, Verdana, Arial, "Trebuchet MS"; text-align: justify;}
p{text-align: justify;}
.box { margin: 10px 0px; padding: 10px; border: 1px solid rgb(200, 202, 206); background-color: rgb(247, 247, 247);}

.clearfix { width: 900px; padding-top: 20px; padding-right: 20px; padding-bottom: 20px; padding-left: 20px; background-color: rgb(34, 34, 34);}
.clearfix:after{ content: ""; display: block; clear: both;}
* html .clearfix {	height: 1%;}
* + html .clearfix { display: inline-block;}

.underline { text-decoration: line-through;}
.blue { color: #000099;}
.bold_blue { color: #000099; font-weight: bold;}
.green {
	color: #558800;
}
.bold_red { font-weight: bold; color: #cc0000;}
.red { color: #cc0000;}
.gray { color: #888888;}
.none { color: #000000;}
.normal{ color: #000000; font-weight: bold;}
hr{ color: #888888;}
.bggray{background-color: #efefef;}
</style>
</head>
<body>
<div id="wrap">
<div class="article">
	<h1>Chapter 06 클래스와 모듈</h1>
</div>
    
<h2>1. 클래스</h2>
<p class="gray">자바스크립트에서도 정식 클래스(class) 문이 추가되었다. 이제 prototype을 사용하지 않고도 좀 더 간단하고 명료하게 상속을 사용할 수 있게 되었고, <span class="normal">정적(static)</span> 함수 선언문이 추가되었다. </p>
<p class="gray">참고) static 키워드는&nbsp;변수나 함수, 클래스에 정적 속성을 부여하는 것으로 클래스로부터 객체를 생성하지 않고 변수나 함수를 호출할 수 있도록 해주는 것이다. 변수이름의 형식으로 곧바로 사용할 수 있게 된다. static 키워드를 사용하는 이유는 자주 변하지 않는 일정한 값이나 설정 정보 같은 공용자원에 대한 접근에&nbsp;있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 전역변수와 같은 개념을 통해서 접근하는 것이 비용도 줄이고 효율도 높일 수 있다. <span class="red"><a href="#static">(4번에서 자세히 설명)</a></span></p>
<p class="gray">클래스는 미리 선언해 두었다가 클래스 선언문의 이름 앞에 new 키워드를 붙여 호출하여 인스턴스를 생성하여 사용하는 것이 기본이며, 이때 클래스 안의 this 키워드는 생성된 인스턴스를 참조한다. </p>
<p class="gray">&nbsp;</p>
<h3>1) 클래스 선언</h3>
<p class="gray">- 클래스의 선언 방법은 class 키워드 뒤에 클래스 명을 붙여 선언해 주고 블록 안쪽에 구문을 작성해 준다. 아래 클래스 선언의 예를 살펴보면 Display 클래스를 선언하고 new 키워드를 붙여 Display 클래스를 호출하여 변수 display에 인스턴스를 참조하였다.</p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_01.html" target="_blank">http://127.0.0.1:8887/ex06_01.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display{  <span class="green">// Display 클래스 선언</span>
  }

  <span class="green">// 선언된 Display 클래스에 new 키워드를 붙여 호출하여 새 이스턴스 생성</span>
  const display = new Display();  </pre>


<p class="gray">&nbsp;</p>
<h3>2) 생성자 함수</h3>
<p class="gray">- 생성자 함수(constructor)는 클래스의 인스턴스 생성 시에 한번 호출되는 함수이며, 내부 구문에 의해서는 호출할 수 없다. 주로 초기 설정의 목적으로 사용되며 인스턴스 호출 시 전달한 인자값이 생성자 함수 매개변수에 전달된다. </p>
<p class="gray">- 생성자 함수는 클래스 블록 안에 선언해 주며 constructor 키워드를 사용하여 선언하되 function은 붙아지 않는다.</p>
<p class="gray"><img src="images/lesson06_01.png" alt="생성자 함수" width="315" height="253" border="1"></p>
<p class="gray">- 아래 생성자 함수 선언 예를 살표보면, Display 클래스를 선언하고, 생성자 함수(constructor)를 클래스 내부에 선언해 주었다. 선언된 클래스를 호출하면서 인자값을 전달해 주었고, 전달된 인자는 생성자 함수 매개 변수에 전달되었음을 볼 수 있다.</p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_02.html" target="_blank">http://127.0.0.1:8887/ex06_02.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display{
      constructor(x, y){  <span class="green">// 생성자 함수 선언</span>
          <span class="green">// 전달인자의 값을 클래스 멤버 변수에 할당</span>
          this.x = x;
          this.y = y;
          console.log(this.x, this.y);  <span class="green">// 결과는 100, 200</span>
      }
  }
  const display = new Display(100, 200);</pre>
<p class="gray">&nbsp;</p>


<h3>3) 프로토타입 메서드</h3>
<p class="gray">- 프로토타입(prototype) 메서드는 인스턴스를 통해서 호출 가능한 함수이다. ECMAScript 이전에는 함수의 prototype 속성에 함수를 추가하여 메서드를 구현하였다. 이 방식은 코드의 가독성이 떨어져 클래스 선언문에 바로 프로토타입 메서드를 선언할 수 있도록 개선되었다. </p>
<p class="gray">- 프로토타입 메서드의 선언 방법은 클래스 선언문 블록 내부에 함수를 선언하되, function은 붙아지 않는다. </p>
<ul>
  <li class="normal">기존 프로토타입 메서드</li>
</ul>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_03.html" target="_blank">http://127.0.0.1:8887/ex06_03.html</a></p>
</blockquote>
<pre class="gray">&nbsp; var Display = function(){
  }
  Display.prototype.foo = function(){
  }</pre>

<ul>
  <li class="normal">ES6 프로토타입 메서드</li>
</ul>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_04.html" target="_blank">http://127.0.0.1:8887/ex06_04.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display{
      foo(){
      }
  }</pre>

<p class="gray">- 다음 코드의 예를 살펴보면 Display 클래스 선언문 안에 foo 메서드를 선언해 주고, Display 클래스의 인스턴스를 생성해 주었다. 생성된 인스턴스를 통해 foo 메서드를 호출할 수 있음을 볼 수 있다. 이때 this 키워드는 생성된 인스턴스를 참조한다.  </p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_05.html" target="_blank">http://127.0.0.1:8887/ex06_05.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display{  <span class="green">// Display 클래스 선언</span>
      foo(){      <span class="green">// foo 메서드 선언</span>
          console.log(this);  <span class="green">// this출력</span>
      }
  }

  const display = new Display();  <span class="green">// Display 클래스 인스턴스 생성</span>
  display.foo();  <span class="green">// foo 메서드 호출, 출력된 this는 생성된 인스턴스를 참조</span></pre>


<p class="gray">&nbsp;</p>
<h3 id="static">4) 정적 메서드</h3>
<p class="gray">- 정적(static) 메서드는 프로토타입 메서드와는 다르게 인스턴스를 통해서가 아닌 클래스 이름 뒤에 바로 메서드 호출을 하며 주로 유틸 함수를 정의할 때 사용된다. static 메서드는 클래스 내부에 static 키워드를 앞에 붙여 메서드를 정의해 준다. </p>
<p class="gray">- 다음 코드의 예를 살펴보면 Display 클래스 선언문 안에 static foo 메서드를 선언해 주고, 인스턴스 생성없이 클래스명 바로 뒤에 static 메서드를 호출해 주고 있다. 이때 this 키워드의 값은 프로토타입 메서드와는 다르게 인스턴스를 참조하지 않고 undefined가 된다. </p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_06.html" target="_blank">http://127.0.0.1:8887/ex06_06.html</a> <span class="red">(실행하면 자기 자신 클래스가 한 번 출력됨)</span></p>
</blockquote>
<pre class="gray">&nbsp; class Display{  <span class="green">// Display 클래스 선언</span>
      static foo(){      <span class="green">// static foo 메서드 선언</span>
          console.log(this);  <span class="green">// this출력</span>
      }
  }

  Display.foo();  <span class="green">// static foo 메서드 호출, 출력된 this는 undefined</span></pre>


<p class="gray">&nbsp;</p>
<h3 id="static">5) 상속</h3>
<p class="gray">- 자바스크립트에서의 상속은 prototype chain 매커니즘을 활용해야 한다. ECMAScript 이전에는 이를 직접 구현해주어야 한다. 부모 클래스의 인스턴스를 생성하여 자식 클래스의 prototype 속성에 참조한다.</p>
<p class="gray">- 다음 코드 예를 살펴보면 Parent 함수의 인스턴스를 생성하고 Child 함수의 prototype 속성에 참조한다. 그럼 Child 함수의 인스턴스를 통한 메서드 호출 시 Parent 함수의 프로토타입 메서드를 호출할 수 있으며, Parent와 동일이름의 prototype을 Child에 추가 시 우선 순위로 Child의 메서드가 호출된다. 이를 'prototype chain'이라고 한다. </p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_07.html" target="_blank">http://127.0.0.1:8887/ex06_07.html</a></p>
</blockquote>
<pre class="gray">&nbsp; var Parent = function(){}  <span class="green">// Parent 함수 선언</span>
  Parent.prototype.foo = function(){  <span class="green">// Parent 함수의 prototype foo 함수 선언</span>
      console.log('foo');
  }
	
  var Child = function(){}  <span class="green">// Child 함수 선언</span>
  var parent = new Parent();  <span class="green">// Parent 함수의 인스턴스 생성</span>
  Child.prototype = parent;  <span class="green">// Child 함수의 prototype 속성에 Parent 함수 인스턴스 참조</span>
	
  var child = new Child();  <span class="green">// Child 함수 인스턴스 생성</span>
  child.foo();  <span class="green">// Child 인스턴스에서 Parent 메서드 호출</span></pre>
<p class="gray">- 위의 상속법은 ES6 이전의 방법이다. 좀 더 완벽한 구현을 위해서는 코드가 추가되어야 하는데, 매우 복잡하고 가독성이 떨어진다. ES6의 클래스는 extends 키워드를 사용하여 보다 쉽게 상속을 구현할 수 있다. 클래스 선언문에 extends 키워드를 붙이고, 뒤에 상속 받을 클래스명을 작성한다. </p>
<p class="gray">- 다음 코드 예를 살펴보면 선언된 Display 클래스를 Rect 클래스 선언문 뒤에 extends 붙여 Display 클래스를 상속받고 있다. 코드가 매우 간결하고 가독성이 뛰어나졌다. </p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_08.html" target="_blank">http://127.0.0.1:8887/ex06_08.html</a> <span class="bold_red">(실행 X : 오류발생)</span></p>
</blockquote>
<pre class="gray">&nbsp; class Display {  <span class="green">// Display 클래스 선언</span>
      constructor() {
      }
  }
	
  class Rect extends Display {  <span class="green">// Display 클래스를 상속받는 Rect 클래스 선언</span>
      constructor() {
      }
  }
	
  const rect = new Rect();  <span class="green">// rect 인스턴스 생성</span></pre>
<p class="gray">- 그런데 <span class="red">인스턴스 생성 시 오류가 발생</span>한다. 원인은 자식 클래스 생성자 호출 시 super 함수를 호출하지 않아서이다. 여기서 super란 부모 클래스의 생성자인데, 자식 클래스에서 생성자 호출 시 부모 클래스가 초기화 되도록 강제적으로 super를 호출하도록 하는 것이다. </p>
<p class="gray">- 다음과 같이 코드를 수정해야 정상적으로 동작할 것이다. </p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_09.html" target="_blank">http://127.0.0.1:8887/ex06_09.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display {  <span class="green">// Display 클래스 선언</span>
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
  }
	
  class Rect extends Display {  <span class="green">// Display 클래스를 상속받는 Rect 클래스 선언</span>
      constructor(x, y, width, height) {
          <span class="normal">super(x, y);</span>  <span class="green">// 부모 클래스의 생성자함수 호출</span>
          this.width = width;
          this.height = height;
      }
  }	
</pre>
<ul>
  <li class="normal">super 키워드를 통한 부모 클래스의 메서드 호출</li>
</ul>
<p class="gray">- 자식 클래스의 메서드에서는 super 키워드를 통해서 부모 클래스의 메서드를 호출할 수 있도록 해준다. 곧 super 키워드는 부모 클래스의 인스턴스라고 볼 수 있는데 오로지 프로토타입 메서드만 호출이 가능하다. </p>
<p class="gray">- 다음 코드를 살펴보면 Display 클래스를 상속받은 Rect 클래스에서 logScale 프로토타입 메서드를 선언하고, super 키워드를 통해 부모 클래스의 logPosition 프로토타입 메서드를 호출하고 있다.
</p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_10.html" target="_blank">http://127.0.0.1:8887/ex06_10.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display {  <span class="green">// Display 클래스 선언</span>
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
		
      logPosition(){
          console.log(this.x, this.y);
      }
  }
	
  class Rect extends Display {  <span class="green">// Display 클래스를 상속받는 Rect 클래스 선언</span>
      constructor(x, y, width, height) {
          <span class="normal">super(x, y);</span>  <span class="green">// 부모 클래스의 생성자함수 호출</span>
          this.width = width;
          this.height = height;
      }
		
      logScale(){
          console.log(this.width, this.height);
          <span class="normal">super.logPosition();</span>  <span class="green">// super 키워드를 통해 부모 클래스의 logPosition 메서드 호출</span>
      }
  }</pre>
<ul>
  <li class="normal">프로토타입 메서드 오버라이딩</li>
</ul>
<p class="gray">- 메서드 오버라이딩이란 부모 클래스의 메서드를 재정의하는 것이다. 이것은 ECMAScript 이전에 사용되었던 프로토타입 체이닝을 대신해 준다. 상속받은 클래스의 메서드 호출 시 자식 클래스의 메서드 목록을 우선으로 찾아 호출해주며, 없을 경우 부모 크래스의 메서드를 조회하여 호출해 준다.</p>
<p class="gray">- 다음 코드의 예를 살펴보면 부모 클래스 logPosition 메서드를 자식 클래스에서 재정의하여 메서드 오버라딩을 하였다. 자식 클래스의 인스턴스 생성 후 logPosition 메서드를 호출하면 부모 클래스의 메서드가 아닌 자식 클래스의 메서드가 호출되는 것을 볼 수 있고, super 키워드를 통해 부모 메서드의 호출이 가능한 것을 볼 수 있다.</p>
<blockquote>
    <p>실행 : <a href="http://127.0.0.1:8887/ex06_11.html" target="_blank">http://127.0.0.1:8887/ex06_11.html</a></p>
</blockquote>
<pre class="gray">&nbsp; class Display {  // Display 클래스 선언
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
		
      logPosition(){
          console.log(this.x, this.y);
      }
  }
	
  class Rect extends Display {  <span class="green">// Display 클래스 상속</span>
      constructor(x, y, width, height) {
          super(x, y);
          this.width = width;
          this.height = height;
      }
		
      logPosition(){  <span class="green">// 메서드 오버라이딩</span>
          console.log('메서드 오버라이딩');
          super.logPosition();  <span class="green">// 부모 클래스 logPosition 메서드 호출</span>
      }
  }
	
  const rect = new Rect(10, 20, 100, 200);  <span class="green">// Rect 클래스 인스턴스 생성</span>
  <span class="green">// logPosition 메서드 호출 </span>
  <span class="green">// 결과는 자식클래스의 메서드가 호출 '메서드 오버라이딩' 출력</span>
  <span class="green">// 자식 클래스에서 부모 클래스 메서드 호출 10, 20 출력</span>
  rect.logPosition(); </pre>
<p class="gray">&nbsp;</p>
<h3>6) 단원 핵심 정리</h3>
<p class="gray">- 이번 장에서는&nbsp;클래스에 대해서 살펴보았다. 다음은 기존 방식과 ES6의 클래스를 비교하여 정리한 표이다. </p>
<table width="100%" border="1">
  <tr>
    <th width="20%">&nbsp;</th>
    <th width="40%">기존 방식</th>
    <th width="40%">class</th>
  </tr>
  <tr>
    <th>prototype 메서드</th>
    <td>함수 prototype 속성에 추가하여 사용한다.<br>
      매번 prototype 키워드를 작성해야 하는 번거로움이 있고, 어떤 위치나 메서드 추가 코드를 작성할 수 있어, 그룹화가 되지 않아 가독성이 떨어진다.</td>
    <td>class 블록 안에 prototype 키워드를 생략하고 작성하며, 메서드가 class 블록 안에 작성되므로 그룹화되어 가독성이 좋아진다.</td>
  </tr>
  <tr>
    <th>상속</th>
    <td>자식 클래스의 prototype 속성이 부모 클래스의 인스턴스를 추가하여 구현한다. 추가로 부모 클래스의 초기화를 구현해 주어야 하고, 정해진 방식이 없어 구현 방식이 모두 다르며, 코드의 가독성이 매우 떨어진다. </td>
    <td>클래스 선언문 뒤에 extends 키워드를 붙여 상속한다. super 함수를 호출하여 부모 클래스를 간단하게 초기화 할 수 있고, 선언 방식이 정해져 있어 코드의 가독성이 좋아진다. </td>
  </tr>
</table>
<p class="gray">&nbsp;</p>
<h3>7) 문제풀면서 복습하기</h3>
<h4>(1) 다음 코드를 ES6의 클래스 상속으로 변경하여 보자. </h4>
<p class="gray">- 먼저 다음 코드를 살펴보면, Animal 클래스가 선언되어 있고, Animal 클래스에는 eat와 sound 프로토타입 메서드가 선언되어 있다. 그 아래에는 Animal 클래스를 상속받는 Dog 클래스와 Tiger 클래스가 선언되었고, 각각 메서드를 오버라이딩하고 있다.</p>
<blockquote>
  <p><a href="ecma6\example\chapter6\6-1\ex01.html" target="_blank">ecma6\<span class="bold_red">example</span>\chapter6\6-1\ex01.html</a></p>
</blockquote>
<pre class="gray">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;클래스(Class)&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
      var Animal = function(){};
      Animal.prototype.eat = function(){
          console.log('먹기');
      }
      Animal.prototype.sound = function(){
          console.log('소리내기');
      }
  
      var Dog = function(){};
      Dog.prototype = new Animal();
      Dog.prototype.sound = function(){
          console.log('멍멍');
      }
      Dog.prototype.eat = function(){
          console.log('사료');
      }
      Dog.prototype.guard = function(){
          console.log('집지키기');
      }
  
      var Tiger = function(){};
      Tiger.prototype = new Animal();
      Tiger.prototype.sound = function(){
          console.log('어흥');
      }
      Tiger.prototype.eat = function(){
          console.log('닭고기');
      }
      Tiger.prototype.attack = function(){
          console.log('공격');
      }
  
      var dog = new Dog();
      dog.sound();
  
      var tiger = new Tiger();
      tiger.sound();
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
<p class="gray">- 작성된 코드를 브라우저의 개발도구 console에서 결과를 확인하면 Dog 클래스와 Tiger 클래스가 Animal 클래스의 메서드를 오버라딩되어 호출되었음을 볼 수 있다.</p>
<p class="gray">- 그럼 이제 위의 코드에서 인스턴스를 생성하는 호스트 코드를 유지한 채 클래스 선언 구문을 ES6의 class로 상속을 extends 키워드를 사용하여 변경해 본다.</p>
<blockquote>
  <p><a href="ecma6\complete\chapter6\6-1\ex01.html" target="_blank">ecma6\complete\chapter6\6-1\ex01.html</a><a href="../source/02/comment.php" target="_blank"></a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://127.0.0.1:8887/chapter6/6-1/ex01.html" target="_blank">http://127.0.0.1:8887\chapter6\6-1/ex01.html</a></p>
</blockquote>
<pre class="gray">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;클래스(Class)&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
  class Animal{  <span class="green">// Animal을 class 선언문으로 변경해 준다.</span>
      constructor(){
  
      }
      eat(){  <span class="green">// prototype 메서드를 class 선언문 안에 prototype 키워드를 생략하고 선언</span>
          console.log('먹기');
      }
      sound(){
          console.log('소리');
      }
  }

  <span class="green">// 인스턴스를 prototype 속성에 붙여 상속 구현하던 구문을 extends 키워드를 사용하여 상속</span>
  class Dog <span class="normal">extends</span> Animal{
      constructor(){
          <span class="normal">super()</span>;  <span class="green">// 부모 클래스 초기화 추가</span>
      }
      sound(){  <span class="green">// 부모 클래스의 메서드 오버라딩</span>
          console.log('멍멍');
      }
      eat(){
          console.log('사료');
      }
      guard(){  <span class="green">// phototype 메서드 추가</span>
          console.log('집지키기');
      }
  }
  
  class Tiger <span class="normal">extends</span> Animal{
      constructor(){
          <span class="normal">super()</span>;
      }
      sound(){
          console.log('어흥');
      }
      eat(){
          console.log('닭고기');
      }
      attack(){
          console.log('사냥');
      }
  }
  
  var dog = new Dog();
  dog.sound();
  
  var tiger = new Tiger();
  tiger.sound();
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
<p class="gray">- 수정한 코드를 살펴보면 선언된 함수를 class 선언문을 이용하여 보다 명확하게 class를 선언해 주고, prototype 메서드는 class 선언문 블록 안에 prototype 키워드를 생략하고 선언해 준다. 인스턴스를 prototype 속성에 추가하여 구현한 상속 구문은 extends 키워드를 사용하여 변경해준다.</p>
<p class="gray">&nbsp;</p>
<p class="gray">&nbsp;</p>
<p class="gray">&nbsp;</p>



<h2>2. 모듈</h2>
<h3>1) 모듈에 맞는 브라우저 설치</h3>
<p class="gray">&nbsp;</p>


<h3>2) 모듈 선언</h3>
<p class="gray">- 모둘은 자바스크립트 코드의 재사용성을 높이는데 매우 도움이 된다. ES6이전에도 모듈화를 구현하기 위한 방법은 존재하였다. 특히 CommonJS와 AMD 라이브러리는 매우 범용적으로 사용되었으며, 지금도 지속적으로 연구되고 있다. 이러한 모듈의 주요 기능은 다음과 같다. </p>
<ul>
  <li class="normal">자신만의 독립적인 실행영역(scope) 갖기</li>
  <li class="normal">전역변수와 지역변수를 나누어 선언</li>
  <li class="normal">비동기로 모듈을 로드하여 사용</li>
</ul>
<p class="gray">- ES6에서의 모듈은 기존 자바스크립트와 동일하지만 &lt;script type=&quot;module&quot;&gt;로 선언해주어야 하며, import와 export 키워드를 추가적으로 사용할 수 있다. 모듈은 자신만의 독립적인 scope를 가지며, 변수 또는 함수 등은 비공개 API로 선언된다. </p>
<p class="gray">- 그런데 모든 API가 비공개라면 코드를 재사용할 수가 없으므로 공개 API를 선언할 수 있어야 하는데, export 키워드를 앞에 붙이고 변수 또는 함수 등을 선언 시 공개 API로 선언된다. </p>
<p class="gray">- 모듈에서 다른 모듈의 공개 API를 사용하기 위해서는 먼저 모듈 로드가 선행되어야 한다. 모듈 로드는 import 키워드를 사용하여 로드할 파일 위치를 지정해 주고, 필요한 공개 API를 설정해줄 수 있다. 그럼 좀 더 자세히 import와 export 키워드를 살펴보자.</p>
<ul>
  <li class="normal">기본값 사용(default)</li>
</ul>
<p class="gray">- 모듈에서 공개 API 선언 시 기본값을 선언해 줄 수 있다. export 키워드 뒤에 default 키워드를 추가해 주면 기본값으로 선언이 된다. 이렇게 내보낸 기본값은 import 키워드 뒤에 명명하여 불러올 수 있다. </p>
<p class="gray">- 다음 예를 살펴보면 먼저 module.js 파일을 생성하고 내보낼 기본값을 선언해 준다. export 키워드 뒤에 default 키워드를 붙이고 함수를 선언해 주었다. index.html에서 import 키워드 뒤에 불러온 API를 참조할 변수를 명명하고, 뒤에 from 키워드를 붙여주어 모듈파일의 위치를 지정하였다. </p>
<p class="gray">- moudule.js</p>
<pre class="gray">  export default function(){  <span class="green">// 기본값 내보내기에 함수를 선언</span>
	    console.log('module import');
  }</pre>
<p class="gray">- <a href="http://localhost:8887/index.html" target="_blank">index.html</a></p>
<pre class="gray">
&lt;script <span class="bold_red">type=&quot;module&quot;</span>&gt;
&nbsp; import foo from '<span class="bold_red">./</span>module.js';  <span class="green">// module.js 모듈을 불러오고 기본값을 foo 변수에 참조</span>
  foo();  <span class="green">// 결과는 'module import' 출력</span>
&lt;/script&gt;</pre>

<ul>
  <li class="normal">기명값 사용</li>
</ul>
<p class="gray">- 모듈 내보내기 시 기명값을 참조할 수 있다. 미리 선언된 기명값을 참조하거나, export 키워드 뒤에 기명값을 선언하여 참조할 수 있다. export 키워드 뒤에 {} 안에 선언된 기명값을 넣어 참조하거나 export 뒤에 기명값을 선언할 수 있다. 내보낸 모듈을 import하여 {} 안에 내보낸 기명값을 같은 이름의 변수에 참조하여 API를 사용할 수 있다. </p>
<p class="gray">- 다음 예를 살펴보면 module.js 파일에 area 함수와 round 함수를 선언하고, export 키워드 뒤에 {} 안에 기명값을 참조하였다. index.html 파일에서 module.js 모듈을 불러와 {} 안에 같은 이름의 변수 선언하여 내보낸 기명값을 참조하였다. </p>
<p class="gray">- moudule.js</p>
<pre class="gray">  export {area, round}  <span class="green">// area 함수와 round 함수 내보내기</span>
	let x = 10;
  let y = 20;

  function area(){return x*y;}
  function round(){return (x+y)*2;}</pre>
<p class="gray">- <a href="http://localhost:8887/index.html" target="_blank">index.html</a></p>
<pre class="gray">
&lt;script <span class="bold_red">type=&quot;module&quot;</span>&gt;
  <span class="green">// module.js 모듈을 불러와 내보낸 기명값을 {}안에 같은 이름의 변수에 참조</span>
  import {area, round} from '<span class="bold_red">./</span>module.js'; 
&nbsp; console.log(area());   <span class="green">// 결과는 200</span>
  console.log(round());  <span class="green">// 결과는 60</span>
&lt;/script&gt;</pre>

<p class="gray">&nbsp;</p>
<ul>
  <li class="normal">기명값에 별칭 부여하여 사용</li>
</ul>
<p class="gray">- 앞서 살펴본 기명값 사용 시 as 키워드를 붙여 별칭을 부여할 수 있다. as 키워드를 붙이고 뒤에 별칭을 명명한다. </p>

<h4 class="normal">(1) 여러 기명값에 별칭 부여</h4>
<p class="gray">- module.js 파일에서 변수 a1, a2를 기명값으로 내보내고, index.html 파일에서 module.js 모듈을 불러와 a1은 b1, a2는 b2로 별칭을 부여하였다. </p>
<p class="gray">- moudule.js</p>
<pre class="gray">  export {a1, a2};  <span class="green">// a1, a2 기명값 내보내기</span>
	var a1, a2;</pre>
<p class="gray">- <a href="http://localhost:8887/index.html" target="_blank">index.html</a></p>
<pre class="gray">
&lt;script <span class="bold_red">type=&quot;module&quot;</span>&gt;
  <span class="green">// a1-&gt; b1, a2-&gt;b2로 별칭을 부여하여 참조</span>
  import {a1 as b1, a2 as b2} from '<span class="bold_red">./</span>module.js'; 
&lt;/script&gt;</pre>

<br/>
<h4 class="normal">(2) 기본값과 기명값을 불러와 별칭 부여</h4>
<p class="gray">- module.js 파일에서 기본값과 변수 a를 기명값으로 내보내고, index.html 파일에서 module.js 모듈을 불러와 기본값은 def로 a는 b로 별칭을 부여하였다. </p>
<p class="gray">- moudule.js <span class="bold_red">(책은 오타)</span></p>
<pre class="gray">  export default{};  <span class="green">  // 기본값 내보내기</span>
	export <span class="bold_red">let</span> a = 100;  <span class="green">// 기명값 내보내기</span></pre>
<p class="gray">- <a href="http://localhost:8887/index.html" target="_blank">index.html</a></p>
<pre class="gray">
&lt;script <span class="bold_red">type=&quot;module&quot;</span>&gt;
  <span class="green">// 기본값은 def, a는  b로 별칭을 부여</span>
  import def, {a as b} from '<span class="bold_red">./</span>module.js'; 
&lt;/script&gt;
</pre>
<p class="gray">&nbsp;</p>


<ul>
  <li class="normal">한꺼번에 공개 API 불러오기</li>
</ul>
<p class="gray">- 앞서 살펴본 모듈 공개 API는 각각 개별키에 참조하여 하나씩 할당해 주었다. <span class="bold_blue">*키워드</span>를 사용하면 개별이 아닌 한꺼번에 API를 불러올 수 있다. 이때 <span class="bold_blue">*키워드</span>는 뒤에 as 키워드를 붙여 별칭을 부여해 주어야 하고, 명명된 키에는 공개 API Module 객체의 속성에 참조된다. </p>
<p class="gray">- 다음&nbsp;예를 살펴보면 module.js 파일에서 기본값과 a, b 기명값을 내보내고, index.html 파일에서 module.js 모듈을 불러와 <span class="bold_red">*키워드</span>를 사용하여 전체 공개 API를 module 변수에 참조하였다. 출력된 module 변수는 Module 객체를 참조하여, 속성으로 공개 API 전부를 참조하고 있음을 볼 수 있다. </p>
<p class="gray"><span class="bold_blue">참고)</span> 키워드는? all 이라는 뜻이다.</p>
<p class="gray">- moudule.js</p>
<pre class="gray">  export default class{};  <span class="green">// 기본값 내보내기</span>
	export {a, b};  <span class="green">         // 기명값 내보내기</span>
  var a = 100;
  var b = 200;</pre>
<p class="gray">- <a href="http://localhost:8887/index.html" target="_blank">index.html</a></p>
<pre class="gray">
&lt;script <span class="bold_red">type=&quot;module&quot;</span>&gt;
  <span class="green">// 모든 공개 API를 module 변수에 참조</span>
  import * as module from '<span class="bold_red">./</span>module.js';
  // 결과는 Module 객체( {a: 100, b: 200, default: class} ) 출력
  console.log(module);
&lt;/script&gt;</pre>


<p class="gray">&nbsp;</p>
<h3>3) 단원 핵심 정리</h3>
<p class="gray">- 다음은 모듈 사용 시 장점을 정리한 표이다. </p>
<table width="100%" border="1">
  <tr>
    <th width="30%">&nbsp;</th>
    <th>모듈 사용 시 장점</th>
  </tr>
  <tr>
    <th>독립적인 실행영역(scope) 생성</th>
    <td>모듈을 사용하면 자동으로 독립적인 실행영역(scope)을 만들어 주므로, 이를 위해 별도의 노력을 기울이지 않아도 되며 작업 시간을 단축시킬 수 있고 외부 라이브러리나 불필요한 코드를 작성하지 않아도 된다.</td>
  </tr>
  <tr>
    <th>비동기 로드</th>
    <td>모듈은 재사용이 쉽도록 미리 작성해 두었다가 필요할 때 로드하여 사용할 수 있어 생산성을 높여 줄 수 있다.</td>
  </tr>
</table>
<p class="gray">&nbsp;</p>
<h3>4) 문제풀면서 복습하기</h3>
<h4>(1) 작성된 클래스를 모듈화 시켜보자</h4>
<p class="gray">- 모듈화하기 전에 작성된 예제를 살펴보면&nbsp;Loader 클래스에서 JSON 데이터를 로드하여 body에 데이터를 출력하도록 작성되어 있다. ex01.html 파일에서 Loader 클래스가 작성된 loader.js 파일을 불러놓고, Loader 클래스의 load 메서드를 호출하면 전달 인자 url에 위치한 파일을 로드하여 응답 데이터를 전달받도록 수행해준다. 코드를 보면서 좀 더 자세히 살펴보면</p>
<p class="gray">- 다음 코드는 body에 노출시킬 JSON 데이터이다. success 속성의 값을 읽어오고 있다.</p>
<blockquote>
  <p><a href="ecma6\example\chapter6\6-2\data\data.json" target="_blank">ecma6\<span class="bold_red">example</span>\chapter6\6-2\data\data.json</a></p>
</blockquote>	
<pre class="gray">  {
      &quot;success&quot;:&quot;성공&quot;
  }</pre>

<p class="gray">- 다음 파일은 Loader 클래스이다. Loader 클래스 인스턴스에 load 메서드를 호출하여 전달인자인 url 값에 위치한 파일의 data를 불러와 이를 콜백 전달해 주고 있다.</p>
<blockquote>
  <p><a href="ecma6\example\chapter6\6-2\js\loader.js" target="_blank">ecma6\<span class="bold_red">example</span>\chapter6\6-2\js\loader.js</a></p>
</blockquote>	
<pre class="gray"><span class="normal">class Loader {</span>  <span class="green">// Loader 클래스 선언</span>
    constuctor(){

    }

    <span class="green">// 인수에 데이터 경로와 데이터를 전달받을 콜백을 전달받음</span>
    <span class="normal">load({url, callback}){</span>
        const promise = new Promise((resolve, reject)=&gt;{
            let req = new XMLHttpRequest();
            req.open('GET', url);
            req.send();
            req.onreadystatechange = ()=&gt;{
                if(req.readyState == req.DONE){
                    if(req.status == 200){
                        <span class="green">// 데이터를 불러오면 콜백함수에 데이터 전달</span>
                        <span class="normal">callback.call(this, req.response);</span>
                    } else {
                        console.log(req.statusText);
                    }
                }
            }
        });
    <span class="normal">}</span>
<span class="normal">}</span></pre>

<p class="gray">- 다음 코드는 Loader 클래스를 불러와 인스턴스를 생성한 뒤 데이터를 불러오도록 load 메서드를 호출하여 전달받은 데이터를 body에 출력하도록 한다.</p>
<blockquote>
  <p><a href="ecma6\example\chapter6\6-2\ex01.html" target="_blank">ecma6\<span class="bold_red">example</span>\chapter6\6-2\ex01.html</a></p>
</blockquote>	
<pre class="gray">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;모듈(Module)&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; <span class="normal">src=&quot;./js/loader.js&quot;</span>&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
      <span class="normal">const loader = new Loader();</span>  <span class="green">// Loader 클래스 인스턴스 선언</span>
      <span class="normal">loader.load({</span>  <span class="green">// 데이터 로드를 수행하도록 메서드 호출</span>
          url:'./data/data.json',
          callback:function(data){  <span class="green">// data 인수에 데이터를 전달받음</span>
              <span class="green">// body에 데이터의 success 속성값을 출력</span>
              document.body.innerHTML = JSON.parse(data).success;
          }
      <span class="normal">});</span>
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  
&lt;/body&gt;
&lt;/html&gt;</pre>

<p class="gray">- 작성된 예를 실행해 보면 다음과 같은 결과가 출력된다. </p>
<p class="gray"><img src="images/lesson06_02.png" alt="모듈예제실행결과" width="474" height="154" border="1"></p>
<p class="gray">- 위에서 살펴본 예제의 Loader 클래스는 모듈화가 되어있지 않아, 비동기로 불러와 사용할 수 없다. 이를 모듈화하여 index.html 파일에서 모듈을 불러와 위와 같은 동작을 하도록 수정해보자.</p>
<p class="gray">- 먼저 Loader 클래스를 모듈화 시켜 보도록 하자. export 키워드를 추가하여 모듈 보내기를 하여 비동기로 모듈을 불러올 수 있도록 변경한다. 이때 모듈 기본값이 되도록 default 키워드를 추가해 주었다.  </p>
<blockquote>
  <p><a href="ecma6\complete\chapter6\6-2\js\loader.js" target="_blank">ecma6\complete\chapter6\6-2\js\loader.js</a><a href="../source/02/comment.php" target="_blank"></a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://127.0.0.1:8887/chapter6/6-2/js/loader.js" target="_blank">http://127.0.0.1:8887/chapter6/6-2/</a><a href="ecma6\complete\chapter6\6-2\ex01.html" target="_blank">js/loader.js</a></p>
</blockquote>
<pre class="gray"><span class="bold_blue">export default class</span><span class="normal"> {</span>  <span class="green">// Loader 클래스 선언</span>
    constuctor(){

    }

    <span class="green">// 인수에 데이터 경로와 데이터를 전달받을 콜백을 전달받음</span>
    <span class="normal">load({url, callback}){</span>
        const promise = new Promise((resolve, reject)=&gt;{
            let req = new XMLHttpRequest();
            req.open('GET', url);
            req.send();
            req.onreadystatechange = ()=&gt;{
                if(req.readyState == req.DONE){
                    if(req.status == 200){
                        <span class="green">// 데이터를 불러오면 콜백함수에 데이터 전달</span>
                        <span class="normal">callback.call(this, req.response);</span>
                    } else {
                        console.log(req.statusText);
                    }
                }
            }
        });
    <span class="normal">}</span>
<span class="bold_blue">}</span></pre>


  
<p class="gray">- 다음은 모듈을 불러올 수 있도록 index.html 파일을 수정해 주도록 하자. Loader 클래스를 불러오는 script 태그를 삭제하고 대신 아래 구문에 import 키워드를 사용하여 모듈을 불러온다. import 키워드를 사용하기 위해서는 script 태그에 type=&quot;module&quot;이 추가되어야 한다. 위에서 default 키워드를 붙여 내보내기 하였으므로, 모듈 명명을 선언하여 전달받는다.</p>
<blockquote>
  <p><a href="ecma6\complete\chapter6\6-2\ex01.html" target="_blank">ecma6\complete\chapter6\6-2\ex01.html</a><a href="../source/02/comment.php" target="_blank"></a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://127.0.0.1:8887/chapter6/6-2/ex01.html" target="_blank">http://127.0.0.1:8887/chapter6/6-2/ex01.html</a><a href="http://localhost/02/comment.php" target="_blank"></a></p>
</blockquote>
<pre class="gray">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;모듈(Module)&lt;/title&gt;
  <span class="green">&lt;!-- loader.js를 불러오는 &lt;script&gt;태그 삭제 --&gt;</span>
  <span class="underline">&lt;script type=&quot;text/javascript&quot; src=&quot;./js/loader.js&quot;&gt;&lt;/script&gt;</span>
  &lt;script <span class="normal">type=&quot;module&quot;</span>&gt;
  <span class="green">// type=&quot;module&quot;을 추가하여 모듈선언</span>
      <span class="green">// import 키워드를 사용하여 모듈을 불러오고 Loader 변수에 할당</span>
      <span class="normal">import Loader from './js/loader.js';</span>

      const loader = new Loader();
      loader.load({
          url:'./data/data.json',
          callback:function(data){
              document.body.innerHTML = JSON.parse(data).success;
          }
      });
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  
&lt;/body&gt;
&lt;/html&gt;</pre>

<p class="none">- 이제 모듈화가 완료되었다. <span class="bold_blue"></span></p>



<p class="gray">&nbsp;</p>
<p class="gray">&nbsp;</p>
<p class="gray">&nbsp;</p>



</div>
</body>
</html>